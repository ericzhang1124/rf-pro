RF 学习

1.File & Directories
* Test Libraries: 存放最低级关键字
* Resources Files: 存放变量和用户关键字
* Variable Files: 比Resource Files更灵活的创建变量

2.Support File Format # 支持的文件格式
* HTML
* TSV
* Plain text format # 重文本-推荐
	两个或以上的空格 or 空格包围管道符号

	** 注意空格数据的 处理 
	管道被空格包围的格式最好
eg.
| *Setting*  |     *Value*     |
| Library    | OperatingSystem |

| *Variable* |     *Value*     |
| ${MESSAGE} | Hello, world!   |

| *Test Case*  | *Action*        | *Argument*   |
| My Test      | [Documentation] | Example test |
|              | Log             | ${MESSAGE}   |
|              | My Keyword      | /tmp         |
| Another Test | Should Be Equal | ${MESSAGE}   | Hello, world!

| *Keyword*  |
| My Keyword | [Arguments] | ${path}
|            | Directory Should Exist | ${path}


	** 从2.7.6版本以后支持 *.robot 的后缀，更容易区分test_data_file和普通纯文本文件(*.txt)

3.four type 
Settings		1) Importing test libraries, resource files and variable files.	
				2) Defining metadata for test suites and test cases.
Variables		Defining variables that can be used elsewhere in the test data.
Test Cases		Creating test cases from available keywords.
Keywords		Creating user keywords from existing lower-level keywords

2.2 Create TestCase
2.2.1 TestCase Syntax
Basc Syntax
Test Case的Setting
	[Documentation]:测试用例的说明文档
	[Tags]：测试用例的tag
	[Setup], [Teardown]:本条测试用例特有的上下文
	[Template]：模板，数据驱动，同一个关键字不同的数据依次的执行
	[Timeout]：测试用例超时
	eg.
*** Test Cases ***
Test With Settings
    [Documentation]    Another dummy test
    [Tags]    dummy    owner-johndoe
    Log    Hello, world!

Test case related settings in the Setting table # 测试用例相关设置，在 *** Settings *** 下
	Force Tags, Default Tags
	The forced and default values for tags.
	Test Setup, Test Teardown
	The default values for test setup and teardown.
	Test Template
	The default template keyword to use.
	Test Timeout
	The default value for test case timeout. Timeouts are discussed in their own section.

2.2.2 Using Arguments
Mandatory arguments #强制参数	一个不能少，位置不能错
Default values # 默认值，
	 Create File | path, content=, encoding=UTF-8 # ‘path’为强制参数， ‘content=’可选参数，无默认值， ‘encoding=UTF-8’可选参数且有默认值

Variable number of arguments
	*var:可变参数

Named arguments
	* 对大小写和空格敏感， 空格敏感即不能‘arg = value’，只能 ‘arg=value’
	* User Keyword 使用时不能带'${}'
	* named arg 要放到普通参数后边，named arg顺序无所谓
Named arguments with variables 

***--Named auguments 和 kw arguments --*** 后续再好好学学

2.2.4 Test Case name and documentation
*** Test Cases ***
Simple
    [Documentation]    Simple documentation
    No Operation

Formatting
    [Documentation]    *This is bold*, _this is italic_  and here is a link: http://robotframework.org
    No Operation

Variables
    [Documentation]    Executed at ${HOST} by ${USER}
    No Operation

Splitting
    [Documentation]    This documentation    is split    into multiple columns
    No Operation

Many lines
    [Documentation]    Here we have
    ...                an automatic newline
    No Operation

2.2.5 Tagging Test Cases
Force Tags: 写在测试套件的Settings中，套件内的所有test case获得此Tag！ 可以通过Remove Tags 删除
Default Tags: 写在测试套件的Settings中，套件内的所有test case 如果没有设置自己的Tags就自动获取Default Tags.如果设置了
...			就不自动获取Default Tags;可以在测试用例的[Tags]设置为None，然后也不会获取到Default Tags了;
...			Remove Tags 同样可以删除Default Tags		
Tags: 

2.2.6 Test Set up and Teardown 
	* 执行在测试套件内的每条testCase前后
	* 可以通过 [Test Setup    关键字 / Test Setup    Run Keywords     关键字1     关键字2   关键字3...]  执行
	* Test teardown 在用例执行失败的时候也可以执行，所以可以用于清理任务
	* Test teardown 内的关键字如果出错，后边的关键字依然会去执行
	* Test Cases表内的[Setup] [Teardown]会覆盖掉套件内的[Test Setup] & [Test Teardown] | 为None干掉套件的[Test Setup] & [Test Teardown] 
	* Setup ,Teardown 后的执行关键字支持变量，这个特性有助于执行不同环境的setup & teardown

2.2.7 Test Templates
	* 将关键字驱动模式 ---> 数据驱动模式
Basic Usage
eg.
*** Test Cases **
Normal test case
    Example keyword    first argument    second argument

Templated test case
    [Template]    Example keyword
    first argument    second argument

    * 支持在Settings表设置Test Template
    * Test Template 可以被 [Template]覆盖，使用None可以干掉Test Template
    * 模板多条测试数据，如果由一条或者多条执行失败，其他的也会自动的继续执行

Templates with embedded arguments
# pass

Templates with for loops
eg.
*** Test Cases ***
Template and for
    [Template]    Example keyword
    :FOR    ${item}    IN    @{ITEMS}
    \    ${item}    2nd arg
    :FOR    ${index}    IN RANGE    42
    \    1st arg    ${index}

2.2.8 Different test case Styles
Keyword-driven style
Data-driven style
	eg.
	*** Settings ***
	Test Template    Login with invalid credentials should fail

	*** Test Cases ***                USERNAME         PASSWORD
	Invalid User Name                 invalid          ${VALID PASSWORD}
	Invalid Password                  ${VALID USER}    invalid
	Invalid User Name and Password    invalid          invalid
	Empty User Name                   ${EMPTY}         ${VALID PASSWORD}
	Empty Password                    ${VALID USER}    ${EMPTY}
	Empty User Name and Password      ${EMPTY}         ${EMPTY}

==

	*** Test Cases ***
	Invalid Password
	    [Template]    Login with invalid credentials should fail
	    invalid          ${VALID PASSWORD}
	    ${VALID USER}    invalid
	    invalid          whatever
	    ${EMPTY}         ${VALID PASSWORD}
	    ${VALID USER}    ${EMPTY}
	    ${EMPTY}         ${EMPTY}

Behavior-driven style
pass

2.3 Create Test Suite
2.3.1 TestCase Files
Documentation 					Used for specifying a test suite documentation
Metadata 						Used for setting free test suite metadata as name-value pairs.
Suite Setup, Suite Teardown 	Specify suite setup and teardown.

2.3.2 Test suite directories
	* 目录里边可以放suite,suite 里可以放suite / test case
	目录
		suite1
			suite1.1
			suite1.2
			...
		suite2
		suite3
		...

	* 执行测试目录
		* 忽略以“.”,"_"开头的文件
		* 目录使用CSV命名的忽略
		* 文件没有可识别后缀的忽略

	* Warning on invalid files
	pass

	* Initialization files--RF 目录的初始化文件
		* __init__.robot or __init__.html
		* 内部不能放testCase, 只支持部分设置
		* 初始化文件内设置的变量和关键字，在低阶suite内不可识别，如果需要通过Resource导入
		* 初始化文件内设置什么
			Documentation, Metadata, Suite Setup, Suite Teardown
				These test suite specific settings work the same way as in test case files.
			Force Tags
				Specified tags are unconditionally set to all test cases in all test case files this directory contains directly or recursively.
			Test Setup, Test Teardown, Test Timeout
				Set the default value for test setup/teardown or test timeout to all test cases this directory contains. Can be overridden on lower level. Support for defining test timeout in initialization files was added in Robot Framework 2.7.
			Default Tags, Test Template
				Not supported in initialization files.

2.3.3 Test suite name and documentation
	* 可以在测试用例集前加前缀设置 测试套件 的执行顺序
		eg.
		01__some_tests.txt,02__more_tests.txt
		01在02前执行，且执行是后将“01__”,"02__"删除掉
2.3.4 Free test suit metadata
	*** Settings ***
	Metadata    Version        2.0
	Metadata    More Info      For more information about *Robot Framework* see http://robotframework.org
	Metadata    Executed At    ${HOST}

2.3.5 Suite setup and teardown
	* suite setup 执行失败后边的case就不会被执行了
	* suite setup 执行失败，suite teardown会执行
	* suite teardown 中一个或多个关键字执行失败，其他的依然可正常的执行
	* suite setpu/teardown 后的关键字支持采用变量模式

2.4 Using Test Libraries
	* 包含最底层的关键字,Libraries 才是和被测对象直接交互的
2.4.1 Import Libraries
	* Library 通常是通过在 Settings table内设置的，但是也支持通过 Import Library 关键字实现
	* Using Library Setting
	eg.
		*** Settings ***
		Library    OperatingSystem
		Library    my.package.TestLibrary
		Library    MyLibrary    arg1    arg2
		Library    ${LIBRARY}		
	* 可以在test case file,resource file, test suite initialization file都可以导入，
		尤其在resource file中导入其他文件就都可以使用

	* Using Import Library Keyword
2.4.2 Specifying(指定) library to import
	* Using library name
		* 给定library库名，RF会在模块的搜索路径里查找
		* 好处是：导入简单，不关心库文件在哪里
		* 缺点是要自己去配置Path文件
	* Using physical path to library
		* 好处是：不用再配置Path文件了
		* 导入文件要有后缀
		* 如果python库通过目录实现则需要在目录后增加 “/”
		eg.
			*** Settings ***
			Library    PythonLibrary.py # 导入python 文件
			Library    /absolute/path/JavaLibrary.java # 绝对路径
			Library    relative/path/PythonDirLib/    possible    arguments # 导入目录实现的库已 “/”结尾，{相对路径}
			Library    ${RESOURCES}/Example.class

		* 一个限制，如果用python去实现库，那么这个库的模块名称，和 class 类名称必须一样
2.4.3 Setting custom name to test library # 设置自定义名称给library
pass

2.4.4 Standard libraries
	* 标准库是跟着RF一起被安装的，其中最特殊的是Build-in 库，他是自动导入的，其他的不用在安装了，但是需要导入

	Normal Stadard Library
		* BuiltIn
		* Collections
		* DateTime
		* Dialog
		* OperatingSystem
		* Process
		* Screenshot
		* String
		* Telnet
		* XML
	Remote Library
	pass

2.4.5 External libraries
	* 需要自己安装的第三方库
	* 安装第三方库阅读一下相应库的安装说明，注意将其依赖的库也安装上

2.5 Variables
2.5.1 Introduction
	* 一个正常的关键字不能让变量指定，但是 可以通过 Run Keywords arg 这个关键自达到将关键字赋值给变量的效果 
	* 变量数据结构 ${} #标准变量, @{} #List, &{} #字典,%{ENV_VAR} #环境变量

2.5.2 Variable Types
	* 大小写敏感，空格和下划线忽略
	* 建议全局变量使用大写(eg. ${PATH}

	Scalar variables
	* 当一个Cell内有唯一一个变量的时候，这个变量就指向他的实际存储，当有多个的时候会将其对象转化为字符串和其他对象连接起来
	* 将对象转化为字符串调用了 java toString(),python __str__()方法

	List variables

		Using list variables with other data:也会表现出粘合成一个字符串的效果
		Accessing individual list items
			*** Test Cases ***
			List Variable Item
			    Login    @{USER}[0]    @{USER}[1] # 使用索引
			    Title Should Be    Welcome @{USER}[0]! # 和其他数据一起时被转化成字符串

			Negative Index
			    Log    @{LIST}[-1] # 负数索引

			Index As Variable
			    Log    @{LIST}[${INDEX}] # 索引值支持使用变量

		Using list variables with settings
			*** Settings ***
			Library         ExampleLibrary      @{LIB ARGS}    # This works
			Library         ${LIBRARY}          @{LIB ARGS}    # This works
			Library         @{NAME AND ARGS}                   # This does not work
			Suite Setup     Some Keyword        @{KW ARGS}     # This works
			Suite Setup     ${KEYWORD}          @{KW ARGS}     # This works
			Suite Setup     @{KEYWORD}                         # This does not work
			Default Tags    @{TAGS}                            # This works

	Dictionary variables
		&{USER} = {'naem':'robot', 'password':'secret'}
		*** Test Cases ***
		Constants
		    Login    name=robot    password=secret
		等价于
		Dict Variable
		    Login    &{USER}
		Using dictionary variables with other data
		Accessing individual dictionary items
			*** Test Cases ***
			Dict Variable Item
			    Login    &{USER}[name]    &{USER}[password] # 访问值
			    Title Should Be    Welcome &{USER}[name]! # 和其他数据一起被转为字符串

			Key As Variable
			    Log Many    &{DICT}[${KEY}]    &{DICT}[${42}] # 支持变量形式访问

			Attribute Access
			    Login    ${USER.name}    ${USER.password} # 如果key是字符串可以使用属性访问格式 ${USER.name}
			    Title Should Be    Welcome ${USER.name}!
		Using dictionary variables with settings
			*** Settings ***
			Library        ExampleLibrary    &{LIB ARGS}
			Suite Setup    Some Keyword      &{KW ARGS}     named=arg

	Evirnonment variable
		格式： %{ENV_VAR_NAME}，其值仅限于字符串

2.5.3 Creating variables

Variable table
	* 我们可以在testCase File 和 Resource File中见到 Variable table(最为常见)
	* 如果由缺点的话就是，变量值永远是字符串类型，不过这个可以通过 Variable File解决
	Creating scalar variables
		* 将字符串赋值给变量，第一列为变量名，第二列为值，如果第二列为空则将一个空字符串赋值给变量
		  当然，也可以将一个已经赋值的变量放在第二列
				*** Variables ***
				${NAME}         Robot Framework
				${VERSION}      2.0
				${ROBOT}        ${NAME} ${VERSION}
		* 也可以加个 “=” 增加可读性
				*** Variables ***
				${NAME} =       Robot Framework
				${VERSION} =    2.0
		* 对于value是一个长文本的问题，首先默认的连接是space,我们可以把多个列的值连接起来，如果是多行我们可以通过修改连接符实现
				*** Variables ***
				${EXAMPLE}      This value is joined    together with a space
				${MULTILINE}    SEPARATOR=\n    First line
				...             Second line     Third line
	
	Creating list variables
		eg.
		*** Variables ***
		@{NAMES}        Matti       Teppo
		@{NAMES2}       @{NAMES}    Seppo
		@{NOTHING}
		@{MANY}         one         two      three      four
		...             five        six      seven

	Creating dictionary variables
		eg.
		*** Variables ***
		&{USER 1}       name=Matti    address=xxx         phone=123
		&{USER 2}       name=Teppo    address=yyy         phone=456
		&{MANY}         first=1       second=${2}         ${3}=third
		&{EVEN MORE}    &{MANY}       first=override      empty=
		...             =empty        key\=here=value #使用等号要转义

		*  ${USER 1.name}  等价于 &{USER 1}[name]
		*  dictionary 的键值是有序的，和他们创建时的顺序一致
			eg. @{NANY} 包含 ['first', 'second', 3]

	Variable File
		见 Resource and variable files

	Setting variables in command line
		pass

	Assigning scalar variables
		* 将关键字Return的值赋值给变量
			*** Test Cases ***
			Returning
			    ${x} =    Get X    an argument
			    Log    We got ${x}!
		* 将关键字Return的值(LIST/DIC)赋值给标量变量也是可以的
			*** Test Cases ***
			Example
			    ${list} =    Create List    first    second    third
			    Length Should Be    ${list}    3
			    Log Many    @{list}
	Assigning list variables
		* eg.
			*** Test Cases ***
			Example
			    @{list} =    Create List    first    second    third
			    Length Should Be    ${list}    3
			    Log Many    @{list}

			*** Test Cases ***
			Example
			    ${list} =    Create List    first    second    third
			    Length Should Be    ${list}    3
			    Log Many    @{list}
			 ********************************************************
			 @{list} =    Create List    first    second    third
			 ${list} =    Create List    first    second    third
			 *********************************************************
			 以上两种无本质上的区别

	Assigning dictionary variables
		* eg.
		*** Test Cases ***
		Example
		    &{dict} =    Create Dictionary    first=1    second=${2}    ${3}=third
		    Length Should Be    ${dict}    3
		    Do Something    &{dict}
		    Log    ${dict.first}

		*Because all Robot Framework variables are stored in the same namespace, it would also be possible to assign a dictionary into a scalar variable and use it later as a dictionary when needed. There are, however, some actual benefits in creating a dictionary variable explicitly. First of all, Robot Framework verifies that the returned value is a dictionary or dictionary-like similarly as it verifies that list variables can only get a list-like value.

		*A bigger benefit is that the value is converted into a special dictionary that it uses also when creating dictionary variables in the variable table. Values in these dictionaries can be accessed using attribute access like ${dict.first} in the above example. These dictionaries are also ordered, but if the original(原始的) dictionary was not ordered, the resulting order is arbitrary(随意的).

	Assigning multiple variables(返回多个值，用不同类型变量接收)
		eg.
		*** Test Cases ***
		Assign Multiple
		    ${a}    ${b}    ${c} =    Get Three # 分别用三个标量变量接收
		    ${first}    @{rest} =    Get Three # 第一个用标量变量接收，剩下的用列表接收
		    @{before}    ${last} =    Get Three # 最后一个用标量变量接收，前面的用列表接收
		    ${begin}    @{middle}    ${end} =    Get Three # 第一个和最后一个用标量变量接收，中间的用列表变量接收

	Using Set Test/Suite/Global Variable keywords
		* BuiltIn Library Keyword
		* 如果该变量已经存在即覆盖掉存在的变量，如果不存在就创建了一个新的变量
		* Set Test Variable：在当前的testcase内任意位置使用，他会在当前的case里改变变量的值，但是不会影响其他case内的变量
		* Set Suite Variable:这个关键字和在Variable table或variableFile设置等效，当前suite均会影响到，但是其他suite /以及当前
		...suite 的子suite都不可见
		* Set Global Variable:小心使用，一处改变处处改变
2.5.4 Built-in variables

	Operating-system variables
		${CURDIR}		当前测试文件所在的绝对路径，大小写敏感
		${TEMPDIR} 		零时文件的绝对路径
		${EXECDIR}		测试开始执行文件的绝对路径
		${/}			系统目录的分隔符. / in UNIX-like systems and \ in Windows.
		${:}			The system path element separator. : in UNIX-like systems and ; in Windows.
		${\n}			换行标识符. \n in UNIX-like systems and \r\n in Windows. New in version 2.7.5.

	Number variables

		*** Test Cases ***
		Example 1A
		    Connect    example.com    80       # Connect gets two strings as arguments

		Example 1B
		    Connect    example.com    ${80}    # Connect gets a string and an integer

		Example 2
		    Do X    ${3.14}    ${-1e-4}        # Do X gets floating point numbers 3.14 and -0.0001

	Boolean and None/null variables
		*** Test Cases ***
		Boolean
		    Set Status    ${true}               # Set Status gets Boolean true as an argument
		    Create Y    something   ${false}    # Create Y gets a string and Boolean false

		None
		    Do XYZ    ${None}                   # Do XYZ gets Python None as an argument

		* 对大小写不敏感的(case-insensitive),因此 ${True} == ${true} 

	Space and empty variables
		*** Test Cases ***
		One Space
		    Should Be Equal    ${SPACE}          \ \

		Four Spaces
		    Should Be Equal    ${SPACE * 4}      \ \ \ \ \

		Ten Spaces
		    Should Be Equal    ${SPACE * 10}     \ \ \ \ \ \ \ \ \ \ \

		Quoted Space
		    Should Be Equal    "${SPACE}"        " "

		Quoted Spaces
		    Should Be Equal    "${SPACE * 2}"    " \ "

		Empty
		    Should Be Equal    ${EMPTY}          \

		## 以下是EMPTY在list 和 dic 中使用
		*** Test Cases ***
		Template
		    [Template]    Some keyword
		    @{EMPTY}

		Override
		    Set Global Variable    @{LIST}    @{EMPTY}
		    Set Suite Variable     &{DICT}    &{EMPTY}

	Automatic variables
	pass

2.5.5 Variable priorities and scopes
Variable priorities  # 变量的优先级


2.6 Create User Keywords

Keyword table 就是用例存放高阶关键字的，通过组合已经存在的关键字！写法和写测试用例类似
2.6.1 User Keywords syntax
Basic Syntax
	eg.
	*** Keywords ***
	Open Login Page
	    Open Browser    http://host/login.html
	    Title Should Be    Login Page

	Title Should Start With
	    [Arguments]    ${expected}
	    ${title} =    Get Title
	    Should Start With    ${title}    ${expected}

	* 用户关键字可以在test case file,resource file,test suite init file里创建！

Settings in the Keyword table
	eg.
	[Documentation]
	Used for setting a user keyword documentation.
	[Tags]
	Sets tags for the keyword.
	[Arguments]
	Specifies user keyword arguments.
	[Return]
	Specifies user keyword return values.
	[Teardown]
	Specify user keyword teardown.
	[Timeout]
	Sets the possible user keyword timeout. Timeouts are discussed in a section of their own.

2.6.2 User Keyword name and documentation
	* keyword name 要具有描述性质
	* [Documentation]的第一行将输出到log日志当中
	* 关键过期或无效了可以对他进行标记，当该关键字被执行时会有相应的提示 *DEPRECATED*

2.6.3 User Keyword tags
	* 他的tag名称不会受force tags,default tags的影响
	* 除了利用[Tags]设置外，也可以通过在[Documentation]的最后一行，Tags:  a, b, c 这样的格式设置

2.6.4 User Keyword arguments
Positional arguments
	eg.
	*** Keywords ***
	One Argument
	    [Arguments]    ${arg_name}
	    Log    Got argument ${arg_name}

	Three Arguments
	    [Arguments]    ${arg1}    ${arg2}    ${arg3}
	    Log    1st argument: ${arg1}
	    Log    2nd argument: ${arg2}
	    Log    3rd argument: ${arg3} 

Default values with user keywords
	* 必须放到positional arguments 后边
	* “=”赋值具有空格敏感的特性，前面有空格不被允许，后面有空格会被当作默认值的一部分
		eg.
		*** Keywords ***
		Two Arguments With Defaults
		    [Arguments]    ${arg1}=default 1    ${arg2}=${VARIABLE}
		    [Documentation]    This keyword takes 0-2 arguments
		    Log    1st argument ${arg1}
		    Log    2nd argument ${arg2}

		*** Test Cases ***
		Example
		    Two Arguments With Defaults    arg2=new value # 调用时可以将{}去掉

Varargs with user keywords # 可变参数
	* 类似Python可变参数语法，注意默认参数！如果调用函数时要传入可变长度参数，默认参数就必须手动赋值了

Kwargs with user keywords # 字典类型参数
	* 类似Python语法，由上传多个key-value数据时，默认参数看以不上传

2.6.5 Embedding arguments into keyword name # 把一个参数买到关键字的名称里边
	* 这种用法的好处是使得关键字的使用更加生活化，更加接近于一个测试用例

Basic Syntax
PASS # 嵌入式关键字语法有点晦涩，暂时跳过了


2.6.6 User Keyword Return Values
	* 通过[Return] \ Built-In关键字Return From Keyword & Return From Keyword If 实现

	Using [Return] Settings
			eg.
			*** Test Cases ***
			Multiple Values
			    ${a}    ${b}    ${c} =    Return Three Values # 分别用三个变量接收
			    @{list} =    Return Three Values # 用一个List接收
			    ${scalar}    @{rest} =    Return Three Values # 用普通变量和列表接收

			*** Keywords ***
			Return Three Values
			    [Return]    foo    bar    zap

	Using Special Keywords to Return
		eg.
		*** Test Cases ***
		One Return Value
		    ${ret} =    Return One Value  argument
		    Some Keyword    ${ret}

		Advanced
		    @{list} =    Create List    foo    baz
		    ${index} =    Find Index    baz    @{list}
		    Should Be Equal    ${index}    ${1}
		    ${index} =    Find Index    non existing    @{list}
		    Should Be Equal    ${index}    ${-1}

		*** Keywords ***
		Return One Value
		    [Arguments]    ${arg}
		    Do Something    ${arg}
		    ${value} =    Get Some Value
		    Return From Keyword    ${value}
		    Fail    This is not executed

		Find Index
		    [Arguments]    ${element}    @{items}
		    ${index} =    Set Variable    ${0}
		    :FOR    ${item}    IN    @{items}
		    \    Return From Keyword If    '${item}' == '${element}'    ${index}
		    \    ${index} =    Set Variable    ${index + 1}
		    Return From Keyword    ${-1}    # Could also use [Return]

2.6.7 User Keyword Teardown
	* 用户关键字有一个 [Teardown]设置
	* 该关键字执行不论成功失败都会执行 teardown 里的设置

2.7 Resource and Variable files
	* Resource file可以帮助我们实现变量的分享
	* Variable file可以让我们快速导入熟悉的变量，尤其是使用.py

2.7.1 Resource Files

	Taking resource files into use
		* 要使用resource file内的数据，通过 *** Settings ***表 Resource  导入resource file
		* 同样可以使用resource file内的从python库导入的关键字和变量

	Resource file Structure
		* 不包含Test Case Tables
		* Settings包含( (Library, Resource, Variables) and Documentation.)
		* Variable table + Keyword table
		* 导入的文件含有含有相同的关键字需要在关键字之前加上文件名 eg.fileName.Keyword
		* 导入的变量有相同的变量名则使用第一个被导入的

	Documenting resource files
		* 支持为Resource文件设置一个Doc

	Example Resource File
		eg.
			*** Settings ***
			Documentation     An example resource file
			Library           Selenium2Library
			Resource          ${RESOURCES}/common.robot

			*** Variables ***
			${HOST}           localhost:7272
			${LOGIN URL}      http://${HOST}/
			${WELCOME URL}    http://${HOST}/welcome.html
			${BROWSER}        Firefox

			*** Keywords ***
			Open Login Page
			    [Documentation]    Opens browser to login page
			    Open Browser    ${LOGIN URL}    ${BROWSER}
			    Title Should Be    Login Page

			Input Name
			    [Arguments]    ${name}
			    Input Text    username_field    ${name}

			Input Password
			    [Arguments]    ${password}
			    Input Text    password_field    ${password}

2.7.2 Variable files
	* variable files allow creating them dynamically and their variables can contain any objects.
		- 变量文件允许动态创建变量 且 变量可包含任意对象
	* 变量文件通常使用.py实现
	* 两种创建变量文件的方法
		- 1.直接创建
		- 2.用特殊的方法 get_variables (or getVariables) 创建

	Taking variable files into use
		* Setting table（方式1）
			- 在设置表里导入变量文件，如果不写绝对路径会先在当前目录找，然后到python模块搜索路径里边找
			- 如果导入的文件需要参数，可以将参数写到文件后点的单元格
			- eg.
				*** Settings ***
				Variables    myvariables.py
				Variables    ../data/variables.py
				Variables    ${RESOURCES}/common.py 
				Variables    taking_arguments.py    arg1    ${ARG2}  # 带参数的变量文件

			- 如果多个变量文件有同名的变量，则最早导入的那个会被使用
			- 变量表和命令行里定义的变量将覆盖变量文件里的变量

		* Command Line (方式2)
			-  --variablefile
					--variablefile myvariables.py
					--variablefile path/variables.py
					--variablefile /absolute/path/common.py
					--variablefile taking_arguments.py:arg1:arg2
			pass

	Creating variables directly # 直接创建

		Basic syntax
			* python文件当中的全局变量将被RF获取，不包括变量名前由下划线的(_XXXX)
					VARIABLE = "An example string"
					ANOTHER_VARIABLE = "This is pretty easy!"
					INTEGER = 42
					STRINGS = ["one", "two", "kolme", "four"]
					NUMBERS = [1, INTEGER, 3.14]
					MAPPING = {"one": 1, "two": 2, "three": 3}
			* 如上边这个文件，这些变量都可以当标量变量使用${}，list和dict也都可以当作列表变量使用(当然dict在被当作列表变量时只包含key)@{}, dict变量可以作为字典变量使用&{}

			* 方便知道创建的变量是什么数据结构，可以使用 LIST__XXXX,DICT__XXXX这样的前缀在.py文件里，但是最后真实的文件名不会包含LIST__,DICT__的前缀！且这样会让RF真实的以@{} or &{} 数据类型存储

		Using objects as values
			* Python中变量指向一个对象，该变量被导入RF后，RF也可以拿到该对象，并可以访问其属性和方法
				.py文件
				class Rootbula:
				    def __init__(self, name):
				        self.name = name

				    def get_phone(self):
				    	return '18476638379'
				    	
				OBJ1 = Rootbula('John')

				RF文件
				*** Test Cases ***
				Get var file data
				    Log     ${OBJ1.name}  # John
				    Log     ${OBJ1.get_phone()} # 18476638379

		Creating variables dynamically
			* 因为变量文件是使用程序语言实现的，所以可以有动态逻辑在设置变量的时候
			* eg. 以下实例变量都是可动态变化的
					import os
					import random
					import time

					PID = os.getpid()                # 获取当前进程号码 
					RANDOM_INT = random.randint(0, 10)  # 获取一个随机数
					CURRENT_TIME = time.asctime()       # 获取当前时间 
					if time.localtime()[3] > 12:	# 使用条件分支给变量赋值
					    AFTERNOON = True
					else:
					    AFTERNOON = False

		Selecting which variables to include
			* 从一个.py导入变量，可以通过在.py文件里__all__=[arg1, arg2, ...]这一个特殊的变量指定哪些数据将被导入，
			其他的列表外数据将不会被导入

	Getting variables from a special function
		* .py实现get_variables | getVariables方法，可被RF调用且预计返回一个python的dictionary，变量名作为key，变量的值就作为值
		* 被创建的变量可以是${} @{} &{} 
		* 同样也可以使用 LIST__, DICT__ 前缀
		* 该方法也可以有参数
			eg.
				variables1 = {'scalar': 'Scalar variable',
				              'LIST__list': ['List','variable']}
				variables2 = {'scalar' : 'Some other value',
				              'LIST__list': ['Some','other','value'],
				              'extra': 'variables1 does not have this at all'}

				def get_variables(arg):
				    if arg == 'one':
				        return variables1
				    else:
				        return variables2

	Implementing variable file as Python or Java class # 用类文件实现变量文件
		* 由于变量文件都是由系统文件路径导入的，者给类的导入带来一定限制
			- Python的类名必须和模块名称一模一样
		* RF框架会自动创建一个不带参数的实例对象（导入的时候发生），变量将会通过这个实例获取到	
			# coding:utf-8

			class StaticPythonExample(object):
				"""docstring for StaticPythonExample"""

				variable = 'valuelala'
				LIST__list = [4,5,6]
				_not_variable = 'starts with an underscore' # 无法导成功导入，私有属性不能直接访问

				def __init__(self):
					self.anothervar = 'another variable' # 可以成功导入
					self.anothername = 'HolyWood' # 可以成功导入
			>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


2.8 Advanced features

2.8.1 Handing Keywords with same names # 处理关键字同名的问题
	* 概念
		LibraryKeywords: 来源于标准库和扩展库
		UserKeywords: 来源于当前文件下和resource file下被用户创建的
 	
 	Key word scopes
 		* 当使用了一个关键字，而这个关键字在几个地方定义了，RF就会根据其优先级决定指向哪一个
 			-1. 在当前文件创建的用户关键字拥有最高的优先级
 			-2. 导入resource file内的关键字拥有第二优先级
 			-3. 在扩展库中的关键字如果和标准库中的关键字重复了就会报警
 			-4. 标准库里的关键字优先级最低

 	Specifying a keyword # 明确指定关键字
 		* ResourceFileName.Keyword
 		* Library.Keyword

 	Specifying explicit priority between libraries and resources # 指定库和资源文件的优先级
 		* 使用Set Library Search Order 这个关键字设置
 		* 详细内容见此关键字 at BUILTIN Library

 2.8.2 Timeouts
 	* 可以对测试用例和UserKeywords设置超时

 	Test Case Timeout
 		* 通过Test Timeout设置，在Settings表里  - 对文件里的所有test cases 生效
 		* 通过[Timeout] 在测试用例表里 - 只对当前的测试用例生效，且会覆盖Settings里的超时设置
 		* [Timeout] 后不添加任何参数 或 添加一个None参数，意思是当前case无超时设置，这个可以将Settings的默认设置覆盖掉
 		* 时间格式可以是“2 minutes” 或 “120” 或 “1 min 30 s”
 		* 超时时间小于1s不建议使用该设置
 		* 如果超时的话会有一个默认的错误信息输出，用户也可以定制该信息，通过在timeouts后添加错误信息，该信息支持多行设置，无论是超时的值还是错误信息都支持变量
 		* 超时的测试用例依然会执行teardown的内容，因为一般这里边有重要的清理行为！如果非要停止teardown也是可能的，通过user keyword timeouts实现
 				Example:
						*** Settings ***
						Test Timeout       1 minutes

						*** Test Cases ***
						Default Timeout
						    [Documentation]     默认使用 Settings 表里的设置
						    Some Keyword    argument

						Override
						    [Documentation]     覆盖掉 Settings 里的默认超时设置
						    [Timeout]   10
						    Some Keyword    argument

						Custom Message  
						    [Documentation]     设置用户超时的错误信息
						    [Timeout]   1 min 30 s      这是我自己的超时错误信息，当超时会被打印出来的
						    Some Keyword    argument

						Variables
						    [Documentation]     时间的长度和错误信息都允许包含变量
						    [Timeout]       ${Timeout}
						    Some Keyword    argument

						No Timeout
						    [Documentation]     设置当前测试用例没有超时
						    [Timeout]       
						    Some Keyword    argument

						No Timeout 2
						    [Documentation]     设置当前测试用例没有超时
						    [Timeout]       NONE
						    Some Keyword    argument
	User keyword timeout
		* 在关键字TABLE里设置[Timeout]
		* 用户关键字里的Timeout对teardown也生效，一旦超时teardown也将不会执行，这一点与Test Case Timeout不同
			Example:
					*** Keywords ***
					Timed Keyword
					    [Documentation]    Set only the timeout value and not the custom message.
					    [Timeout]    1 minute 42 seconds
					    Do Something
					    Do Something Else

					Wrapper With Timeout
					    [Arguments]    @{args}
					    [Documentation]    This keyword is a wrapper that adds a timeout to another keyword.
					    [Timeout]    2 minutes    Original Keyword didn't finish in 2 minutes # 用户错误信息
					    Original Keyword    @{args}

					Wrapper With Customizable Timeout
					    [Arguments]    ${timeout}    @{args}
					    [Documentation]    Same as the above but timeout given as an argument.
					    [Timeout]    ${timeout}
					    Original Keyword    @{args}	
2.8.3 For Loops
	Normal For Loops
		Example:
				*** Settings ***
				Library     varForRF.py # 封装了一个加法方法meth_of_add给Example 3使用

				*** Variables ***
				${last}     last
				@{girlfriend}   Emmy    Sara    Blanda # Example 3 使用
				${count}    ${1} # Example 3使用

				*** Test Cases ***
				Example 1
				    :FOR    ${var}  IN      cat     dog
				    \       Log     ${var}
				    \       Log     another keyword
				    Log     for loop end

				Example 2
				    :FOR    ${var}    IN    one    two
				    ...     ${3}    four    ${last}
				    \    Log    ${var}

				Example 3
				    :FOR    ${girl}     IN      @{girlfriend}
				    \       Log     ${girl} is my ${count} girlfriend
				    \       ${count}=   meth_of_add   ${count}  ${1}

	Nested for loops # 嵌套For循环
		* 不可以直接实现，但是可以通过一个含有for循环的关键字放入For循环以实现--个人觉得好难用，还是直接用python实现较好

	Using several loop variables 
		Example：
			*** Test Cases ***
			Three loop variables
			    :FOR    ${index}    ${english}    ${finnish}    IN
			    ...     1           cat           kissa
			    ...     2           dog           koira
			    ...     3           horse         hevonen
			    \    Add to dictionary    ${english}    ${finnish}    ${index}
			    :FOR    ${name}    ${id}    IN    @{EMPLOYERS}
			    \    Create    ${name}    ${id}

	For-in-range loop # 可以指定循环执行的次数
		Example：
				*** Test Cases ***
				Only upper limit
				    [Documentation]    Loops over values from 0 to 9  # 最简单的用法，指定循环次数的上限
				    :FOR    ${index}    IN RANGE    10
				    \    Log    ${index}

				Start and end
				    [Documentation]  Loops over values from 1 to 10  # 指定循环开始和结束
				    :FOR    ${index}    IN RANGE    1    11
				    \    Log    ${index}

				Also step given
				    [Documentation]  Loops over values 5, 15, and 25 # 指定循环的开始、结束和步距
				    :FOR    ${index}    IN RANGE    5    26    10
				    \    Log    ${index}

				Negative step
				    [Documentation]  Loops over values 13, 3, and -7 # 逆序步距
				    :FOR    ${index}    IN RANGE    13    -13    -10
				    \    Log    ${index}

				Arithmetics
				    [Documentation]  Arithmetics with variable
				    :FOR    ${index}    IN RANGE    ${var}+1
				    \    Log    ${index}

				Float parameters
				    [Documentation]  Loops over values 3.14, 4.34, and 5.54  # 支持小数
				    :FOR    ${index}    IN RANGE    3.14    6.09    1.2
				    \    Log    ${index}

	For-in-enumerate loop #  枚举的循环方式
		Example:
			*** Variables ***
			@{myschool}     Xinghuo     xidian      yanan

			*** Test Cases ***	 # 方式一
			Output my school
			    [Documentation]     练习使用一种带有索引的For循环
			    :FOR    ${index}    ${schoolname}       IN ENUMERATE    @{myschool}
			    \       Log     ${index}:${schoolname}

			*** Test Case ***   # 方式二
			For-in-enumerate with two values per iteration
			    :FOR    ${index}    ${english}    ${finnish}    IN ENUMERATE
			    ...    cat      kissa
			    ...    dog      koira
			    ...    horse    hevonen
			    \    Add to dictionary    ${english}    ${finnish}    ${index}

	For-in-zip loop # 
		* zip()方法是python的一个内置方法，该方法将多个列表打包成一个列表，按顺序取出每个列表的元素组装为一个元组，然后这些元组在组成一个列表返回
			实例:
				name = ['zhangsan', 'lisi', 'wangwu', 'zhaoliu']
				score = [67, 78, 77,88]
				zip(name,score)返回一个列表[('zhangsan',67), ('lisi', 78), ('wangwu', 77), ('zhaoliu', 88)]

		* RF 中使用注意IN ZIP后的列表变量必须使用${}, 而不能使用@{}
				*** Variables ***
				@{myschool}     Xinghuo     xidian      yanan
				@{level}        小学         中学           大学
				*** Test Cases ***
				Output my school 2
				    [Documentation]     练习使用FOR ZIP
				    :FOR    ${le}   ${sn}   IN ZIP  ${level}    ${myschool}  #注意该处变量使用的是${},而不是@{}
				    \       Log     ${le}在${sn}读的

	Exiting for loop  # 退出for循环
		* 正常for循环是在执行完成或遇到异常退出才会结束，如果要想在这之前结束可以通过关键之 Exit For Loop | Exit For Loop If,他的作用好比Python里的break
		* Exit For Loop | Exit For Loop If 只能在For Loop中使用，在外使用会报错
			Example:
				*** Test Cases ***
				Exit Example
				    ${text} =    Set Variable    ${EMPTY}
				    :FOR    ${var}    IN    one    two
				    \    Run Keyword If    '${var}' == 'two'    Exit For Loop  # 也可以写成 **Exit For Loop If 	'${var}' == 'two'**
				    \    ${text} =    Set Variable    ${text}${var}
				    Should Be Equal    ${text}    one

	Continuing for loop # 退出当前循环进入下一次循环
		* 关键字 Continue For Loop && Continue For Loop If， 同Python中的continue

2.8.4   Conditional execution # 条件执行
	
	* 首先在Test Case 或 User Keyword当中不推荐使用各种条件逻辑，因为这会使得难以理解和维护，这部分工作应该放在Library里使用编程语言实现
	* 但是有些时候这种逻辑控制是有用的，RF内没有真正的if/else结构语句，但是有几种方式来实现这种需求
		-1.Run Keyword
		-2.Run Keyword If  &  Run Keyword Unless
		-3.Set Variable If
		-4.还有几个关键字可以执行指定的关键字，当测试用例或测试套件执行失败或通过的时候

2.8.5   Parallel execution of keywords # 并行执行关键字
	* 需在底层Library内实现
	* 见OperatingSystem library库 ，Start Process and Read Process Output 关键字

3.Executing Test cases
3.1 Basic Usage
3.1.1 Starting test execution
	Synopsis # 简介
		robot [options] data_sources # 直接使用robot ， 之后可以添加目录执行目录里的所有case
		python|jython|ipy -m robot [options] data_sources # 用python,可以再去找robot所在的目录了
		python|jython|ipy path/to/robot/ [options] data_sources

	Specifying test data to be executed # 指定执行测试数据
		robot tests.robot # 执行suite file
		robot path/to/my_tests/ # 执行目录
		robot c:\robot\tests.robot # 绝对路径

		robot my_tests.robot your_tests.robot 
			# RF首先将使用my_tests和your_tests组装一个顶级suite(my_tests&your_tests),然后是
			my_tests&your_tests.my_tests和my_tests&your_tests.your_tests

			# 如上，这样的顶级suite的名称太长了，一般会通过给顶级suite指定一个名称如:
			robot --name MyTopSuite my_tests.robot your_tests.robot
			MyTopSuite.my_tests  和  MyTopSuite.	your_tests

3.1.2   Using command line options
	Using options
		* 在robot脚本和test cases路径之间使用 OPTION
			比如：
			-1.	robot -L debug my_tests.robot  
			-2.	robot --include smoke --variable HOST:10.0.0.42 path/to/tests/
	
	Shor and long options # 命令行选项中的长短命令
		* --name 可以缩写为 -N
		* 执行的时候可以使用缩写，但是对于start-up script建议使用全名，因为这样更容易理解
		* long options对大小写不敏感,如--suitestatlevel 可以写为 --SuiteStatLevel,增加可读性
	
	Setting option values
		* 很多的设置都会有一个值，比如:	:--include tag or -i tag. 
		* 也可以如此 --include=tag
		* 可以使用多次的option| --variable VAR1:value --variable VAR2:another
		* 相同的变量名在此设置，只有最后一个生效

	Disabling options accepting no values
		PASS

	Simple patterns # 简单的字符匹配
		* "*" 通配符，可以匹配人资字符串包含空的字符串
		* "?" 统配符，匹配单个任意字符
			Example：
				--test Example*     # Matches tests with name starting 'Example', case insensitively.
				--include f??       # Matches tests with a tag that starts with 'f' or 'F' and is three characters long.
	
	Tag patterns
		AND or & # 且
		The whole pattern matches if all individual patterns match. AND and & are equivalent:

		--include fooANDbar     # Matches tests containing tags 'foo' and 'bar'.
		--exclude xx&yy&zz      # Matches tests containing tags 'xx', 'yy', and 'zz'.
		>>>>>>>>>>>>>>>>>>---------分割线---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		OR # 或
		The whole pattern matches if any individual pattern matches:

		--include fooORbar      # Matches tests containing either tag 'foo' or tag 'bar'.
		--exclude xxORyyORzz    # Matches tests containing any of tags 'xx', 'yy', or 'zz'.
		>>>>>>>>>>>>>>>>>>---------分割线---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		NOT # 非
		The whole pattern matches if the pattern on the left side matches but the one on the right side does not. If used multiple times, none of the patterns after the first NOT must not match:

		--include fooNOTbar     # Matches tests containing tag 'foo' but not tag 'bar'. # 有foo而没有bar的case
		--exclude xxNOTyyNOTzz  # Matches tests containing tag 'xx' but not tag 'yy' or tag 'zz'. # 有xx 而没有yy 或 zz tag的cases
		Starting from Robot Framework 2.9 the pattern can also start with NOT in which case the pattern matches if the pattern after NOT does not match:

		--include NOTfoo        # Matches tests not containing tag 'foo' # 除foo以外的cases全部执行
		--include NOTfooANDbar  # Matches tests not containing tags 'foo' and 'bar' # 除foo 和 bar 以外的cases全部执行

		>>>>>>>>>>>>>>>>>>---------分割线---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

		可以混合到一起使用[AND | OR | NOT]
		--include xANDyORz      # Matches tests containing either tags 'x' and 'y', or tag 'z'.
		--include xORyNOTz      # Matches tests containing either tag 'x' or 'y', but not tag 'z'.
		--include xNOTyANDz     # Matches tests containing tag 'x', but not tags 'y' and 'z'.

		>>>>>>>>>>>>>>>>>>---------分割线---------->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		操作符本身对大小写敏感，只能使用大写

	ROBOT_OPTIONS and REBOT_OPTIONS environment variables
	PASS

3.1.3 Test results
	Command line Output # 普通的控制台执行输出
	Generated output files # 生成输出文件.xml report.html log.html
	Return codes # 返回码
		RC 			Explanation		
		0			所有关键用例全部通过
		1-249		关键用例执行失败的数量
		250			250或更多的关键用例执行失败
		251			帮助或版本信息打印输出
		252			非法的测试套件或命令行参数错误
		253			用户结束执行
		255			内部错误
		* Return code 的作用是当要设计执行失败去做什么的场景中可以使用

	Errors and warnings during execution
		* 在log文件查看

3.1.4 Escaping complicated characters
PASS

3.1.5 Argument files
	* 参数文件允许将所有或一些命令行选项和参数放到一个外部文件中，在那里它们将被读取。
	* 在命令行这样引用 ， --argumentfile (-A)
	* --ArgumentFile 也可以使用但是只能在3.0.2或更新的版本使用

	Argument file syntax
		* 参数文件里可以包含options和测试数据路径，每行一个option 或 测试数据资源
		* 参数文件内可以包含任意字符而无需转义
		* 每行的行首空格和行末空格都会被忽略
		* 空行和(#)开头的行将被忽略掉
			Example:
			--doc This is an example (where "special characters" are ok!)
			--metadata X:Value with spaces
			--variable VAR:Hello, world!
			# This is a comment
			path/to/my/tests
		* 可以通过以下三种方式给option赋值,都是一样的
			Example:
			--name An Example
			--name=An Example
			--name       An Example
		* 如果文件中包含non-ASCII characters，则必须以UTF-8格式存储

	Using argument files
		* argument file可以单独使用，也可以和其他options一起使用
		* argument feles里的options将被放置到所在的位置，也就是说file前的option会被file里的option覆盖,file后的option会覆盖file里的option
			Example:
			robot --argumentfile all_arguments.robot
			robot --name Example --argumentfile other_options_and_paths.robot
			robot --argumentfile default_options.txt --name Example my_tests.robot
			robot -A first.txt -A second.txt -A third.txt tests.robot

	Reading argument files from standard input
		* STDIN : 特别的参数文件，可以使用指定的标准输入流代替file，这将很有用在使用脚本生成参数的时候
			Example:
			generate_arguments.sh | robot --argumentfile STDIN
			generate_arguments.sh | robot --name Example --argumentfile STDIN tests.robot

3.1.6   Getting help and version information
	$ robot --version
	Robot Framework 3.0 (Jython 2.7.0 on java1.7.0_45)

	C:\>rebot --version
	Rebot 3.0 (Python 2.7.10 on win32)

3.1.7   Creating start-up scripts # 启动脚本后续使用再查看使用方法
	* 在持续化集成和自动化执行测试用例中，这样的启动脚本很有用
	* 可以使用unix下的bash，win下的批文件脚本 或 python程序编写启动脚本
		Example:
		# 使用不同的浏览器执行一个web测试, 然后将结果结合起来
		#!/bin/bash
		robot --variable BROWSER:Firefox --name Firefox --log none --report none --output out/fx.xml login
		robot --variable BROWSER:IE --name IE --log none --report none --output out/ie.xml login
		rebot --name Login --outputdir out --output login.xml out/fx.xml out/ie.xml

3.1.8   Debugging problems

3.2   Test execution
	* 本部分主要讲，1.测试套件如何从解析的测试数据创建的；2.如何遇到执行失败继续执行；3.如何优雅停止测试执行

3.2.1   Execution flow
	Executed suites and tests
		* 可以指定执行特定的case |python -m robot --test Example_1 test_for_loop.robot 
			-|  --test, --suite, --include and --exclude

	Setups and teardowns
		* Setup 和 teardowns可以在测试套件、测试用例、用户关键字三个级别使用
		* Keyword teardown #关键字只有teardown，

	Execution order
		* 测试套件中的用例执行是按照定义的顺序进行的
		* 测试套件中还有其他测试套件，他们的顺序呢是根据套件名称的字母顺序排序的
		* 在命令行中，测试套件或目录的执行中是按照命令行要求的顺序执行的
		* 可以通过给特使套件和目录前增加“01__”前缀,指定其执行的顺序
			01__my_suite.html -> My Suite
			02__another_suite.html -> Another Suite
		* 可以通过argument对测试套件、目录的执行进行排序

	Passing execution
		* Pass Execution and Pass Execution If # 内置关键字

3.2.2   Continue on failure
	Run Keyword And Ignore Error and Run Keyword And Expect Error keywords
		* Run Keyword And Ignore Error
		* Run Keyword And Expect Error
		# 以上的关键字可能使得测试用例更加复杂，以下的方法可能会更加有效

	Special failures from keywords
		* test Library可以通过except实现失败后的处理，详见 test library API chapter部分

	Run Keyword And Continue On Failure keyword

	Execution continues on teardowns automatically # teardowns内的关键字在case或suite执行失败也可正常执行

	All top-level keywords are executed when tests have templates
	# 所有高阶关键字将被执行（哪怕其中有失败的），在使用模板的时候

3.2.3   Stopping test execution gracefully
	* Press "Ctrl+C" 停止执行测试，双击将不会输出report和log

	pass

3.3   Post-processing outputs

跳过很多内容
...

4. Extending Robot Framework
 	4.1 Create test libraries
 	4.2 Remove library interface
 	4.3 Listener interface
 	4.4 Extending teh Robot Framework JAR

4.1 Create test libraries
 	* 创建自己的库是很简单明了的

4.1.1 Introduction 

 	* Different test library APIs 
 		Static API
 			# 最简单的是使用python的模块和类实现，可以传递参数，可以使用except输出错误信息，可以返回值
 		Dynamic API
 			# 动态库是类s,实现一个特殊方法获取关键字的名称，另外一个特殊方法执行关键字！关键字如何被执行将至执行时做出决定
 		Hybrid API
 			# 库也是类s实现的，使用一个方法说明实现了哪些关键字，且这些关键字可以直接被使用

4.1.2   Creating test library class or module
	# 库可以通过python的模块和类来实现

	Test Library names
		* 导入python文件，使用模块名称
		* 导入一个python文件，内部是用类实现的，如果模块名称和类名称一样，RF将会舍弃掉类的名称
		* 如果模块名称和类名称不一致，则在导入时需要将模块名称和类名称都写上，如mymodule.MyLib or parent.submodule.MyLib

	Providing arguments to test libraries
		* 使用类实现的库可以使用参数，这些参数可以放置到RF Settings表 内的Library库后边，传递给构造函数
		* 使用模块创建的库就不能传递参数了，否则会报错的
			# ** MyLibrary.py **
			from example import Connection

			class MyLibrary:

			    def __init__(self, host, port=80):
			        self._conn = Connection(host, int(port))

			    def send_message(self, message):
			        self._conn.send(message)

			# RF调用关键字
			*** Settings ***
			Library    MyLibrary     10.0.0.1    8080

	Test library scope
		* 可以通过ROBOT_LIBRARY_SCOPE属性给类设置Scope
		* 默认值是TEST CASE
		* TEST SUITE
		* GLOBAL
			class ExampleLibrary:

			    ROBOT_LIBRARY_SCOPE = 'TEST SUITE' #在此设置

			    def __init__(self):
			        self._counter = 0

			    def count(self):
			        self._counter += 1
			        print self._counter

			    def clear_counter(self):
			        self._counter = 0
	
	Specifying library version
		* 使用ROBOT_LIBRARY_VERSION 或 __version__属性

	Specifying documentation format
		* 使用 ROBOT_LIBRARY_DOC_FORMAT 设置说明文档的格式
		* 支持的格式有ROBOT (default), HTML, TEXT (plain text), and reST
		* 使用reST 需要安装docutils模块
			#Example：
			"""A library for *documentation format* demonstration purposes.

			This documentation is created using reStructuredText__. Here is a link
			to the only \`Keyword\`.

			__ http://docutils.sourceforge.net
			"""

			ROBOT_LIBRARY_DOC_FORMAT = 'reST'

			def keyword():
			    """**Nothing** to see here. Not even in the table below.

			    =======  =====  =====
			    Table    here   has
			    nothing  to     see.
			    =======  =====  =====
			    """
			    pass 

	Library acting as listener # 库作为监听器
		* 使用 ROBOT_LIBRARY_LISTENER 设置一个接听器，其值是一个监听器实例
		* 详见 Test Library as Listener

4.1.3 Create static Keywords
	What methods are considered keywords # 哪些方法将被认为是关键字
	